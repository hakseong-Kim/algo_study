# 무식하게 풀기 (6장 전반부)

1. ### 개요

    프로그래밍 대회에서 대부분의 사람들이 가장 많이 실수를 하는 실수가 쉬운문제를 어렵데 푸는 것이며 이는 공부를 하면 할 수록 어려문 문제를 풀기 때문에 쉬운문제를 봐도 어렵게 접근을 해서 간단히 넘어 갈 수 있는 쉬운문제를 간과하고 넘거가는 문제가 발생을 함
    그래서 알고리즘에 발생할 수 있는 경우의 수를 일일히 입력을 해서 짧은 문제들을 해결하는 방식을 무식하게 푼다(brute-force), 즉 완전 탐색(exhaustive search)라 부른다
    
     - 예시) 열명의 학생을 일렬로 새우되, 사이가 안좋은 학생들을 따로 떨어놓아야 하는 알고리즘 문제의 경우, 별도의 다른 조건을 해놓지 않고, 일일히 떨어트려서 계산을 해놓게 될 시 총 360만 가지의 경우의 수가 발생을 하고 무식한 형태의 코딩 소스이지만, 실제로 계산을 하는 컴퓨터의 입장에서는 간편하게 문제를 풀어나갈 수 있다.

2. ### 재귀 호출과 완전 탐색

   컴퓨터가 사용하는 많은 작업들은 대개 각 형태가 유사한 조각들로 나누어져 있으며, 그 작업들을 진행하는 방식을 반복문과 재귀함수(혹은 재귀호출) 2가지로 나눌 수 있다

     - 반복문과 재귀함수의 특징 및 차이점
          ###### a. 반복문보다 재귀함수의 소스가 변수의 사용을 줄여준다
          ###### b.  반복문보다 재귀함수의 소스가 직관적이며, 가독성이 좋다 
          ###### c.  단 반복문보다 재귀함수의 소스가 이해하는데 시간이 많이 걸린다(재귀보다 반복문에 적응되어있는 사람들이 많으므로)
          ###### d.  단 반복문보다 재쉬함수의 소스가 메모리를 많이 차지해 성능이 반복문보다 느리다(함수를 호출 시 함수의 매개변수, 지역변수, 리턴 값, 그리고 함수 종료 후 돌아가는 위치가 스텍 메모리에 들어가며, 이 함수를 반복했을때 스택 메모리의 과부하에 따라 스택 오버 플로우가 발생할 수 있다)
          ###### e.  단 반복문보다 재귀함수의 소스가 시스템 오버헤드를 유발하는 경우가 크다(제귀함수가 반복문을 이용하는 것에 속도는 느리지만, 그만큼 성능을 보장한다)
          ###### f.  단 코드 유지보수를 위해서는 거대한 모듈을 작은 부품과 같이 쪼개서 관리를 해야하니 이때는, 재귀함수가 요구되는 경우가 많다

     - 예) 1부터 5까지 합을 계산하는 반복문과 재귀함수

      ```python
      # 일반 반복문
        a = 5 # 반복지점 설정
        sum = 0
        for n in range(1,a+1):
          sum = sum + n

        print(sum)
      # 재귀호출

        def recursiveSum(n):
        if(n==1): return 1
        return n+ recursiveSum(n-1)

        a = 5
        print(recursiveSum(a))
      ```
      
  3. ### 완전 탐색과 시간 복잡도를 비교를 한다면
      - 완전 탐색의 경우 모든 경우의 수를 만들면서 가기 때문에 경우의 수가 많이 발생하는 조건이 발생시 사용하기에 에로사항이 많다.
        -> 완전탐색의 길이가 조건보다 길다면, 뒷 장에서 다루는 설계 페러다임을 사용해야 한다.
        
        
  4. ### 완전 탐색 레시피
      - 1과 2,3를 참고를 해서 완전 탐색(재귀 함수)에 대한 방법 과정은 다음과 같다.
        ###### a. 완전 탐색은 모든 답을 하나씩 검사하므로, 걸리는 시간은 가능한 답의 수에 비례하며, 문제 조건 시간보다 오래 걸리는 경우, 다른 설계 페러다임을 사용해야함
        ###### b. 모든 답의 후보를 만드는 과정을 진행을 한다
        ###### c. 하나의 조각을 선택해 답의 일부를 만들고, 나머지 답을 재귀 호출을 통해 완성한다
        ###### d. 조각이 하나밖에 남지 않은 경우, 혹은 하나도 남지 않은 경우 답을 생성했으므로, 이것을 기지 사례로 선택해 처리합니다.
          
      - ** 기저 사례 : 재귀함수를 호출하기 전, 경우의 수를 벗어나는 조건에 해당이 되었을 시 자신을 호출하지 않고 함수를 종료하는 사례
        (예 : 입력받는 숫자중에서 3의 배수만 출력하는 함수에서 짝수가 입력되었을 경우, 재귀함수를 거치지 않고 종료를 한다.)
        
      - 참고) 기존에 문제를 풀었던 막대기 문제[[문제보기](https://www.acmicpc.net/problem/1094)]를 다시 재귀함수 형태로 표현
         

      ```python
      # 일반 반복문
      ## input이 있으니 python으로 실행 후 내용을 입력해야함
      ex = 60
      a = 64
      count = 0
      while True:
        if a <= ex:
          count = count + 1
          ex = ex - a
        if a == 1:
          break
        a = a / 2

      print(count)
      # 재귀호출
      ex = 0 # 실제 투입되는 막대기의 길이
      a = 64 # 비교를 하는 막대기의 길이
      count = 0 # 막개기가 적용된 갯수

      def makdegi(ex, a, count):
        if ex < 1:
          return False #기저 사례 -  입력한 수가 1보다 작거나 64보다 클 경우 함수 제외
        if a == 1:
          return count
        if a <= ex:
          count = count + 1
          return makdegi((ex - a), a, count)
        return makdegi(ex, (a / 2), count)

      print(makdegi(ex,a,count))
      ```
        
   
