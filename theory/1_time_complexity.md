### 시간 복잡도

보통 `Big-O` 표기법 사용

`Big-O`  표기법에서 **중요한 것은 정해진 표현식에 가장 큰 영향을 미치는 n 의 단위이다(최고차수, 쉽게 말해 최악의 경우)**

`O(1) < O(logn) < O(n) < O(nlog n) < O(n^2) < O(n^3) < O(2^n) < O(n!)`





##### 점근적 표기법

- O (빅 오)

  - 점근적 상한선


  - 주어진 알고리즘이 아무리 좋지 않아도 비교하는 함수와 같거나 좋다.

- Ω (오메가)

  - 점근적 하한선
  - 주어진 알고리즘이 아무리 좋아도 비교하는 함수보와 같거나 좋지 않다.

- Θ (세타)

  - 점근적 상한과 하한의 교집합
  - 주어진 알고리즘이 아무리 좋거나 좋지 않아도, 비교하는 함수의 범위 안에 있다.



- - ​



##### Ex)

- 합병정렬의 시간 복잡도
  - 합병정렬이란?
    - 분할 정복법(divide and conquer)을 사용하는 알고리즘
    - 전체 원소를 동일한 크기로 분할 후, 분할한 원소를 다시 병합하는 정렬 방식
  - 시간 복잡도(O)
    - 크기가 N인 배열을 반씩 분할 한다고 하면, N/2인 배열이 2개, 여기서 또 반씩 분할하면, N/4인 배열이 4개 ...로 진행된다.
    - 여기서, 분할 단계에서 분할되는 깊이가 logN에 비례한다. (분할 과정에서 매번 반씩 감소하므로, 반씩 줄어든다면 밑이 2인 logN 만큼 반복해야 크기가 1인 배열로 분할 가능하기 때문)
    - 합병 단계에서 최대 N번의 비교 연산을 하기 때문에 시간 복잡도는 최종적으로 `O(NlogN)`이 된다.



- 이진 탐색 트리의 시간 복잡도
  - 이진 탐색 트리란?
    - 이진 트리 기반의 탐색을 위한 자료 구조. 정렬된 반으로 계속해서 나누어 탐색하는 방법
    - 반드시 정렬된 자료에서만 사용해야 한다.
  - 이진 탐색 트리의 조건
    - 모든 노드의 키는 유일하다.
    - 윈쪽 서브 트리의 키들은 루트의 키보다 작다.
    - 오른쪽 서브 트리의 키들은 루트의 키보다 크다.
    - 왼쪽과 오른쪽 서브트리도 이진 탐색 트리이다.
  - 시간 복잡도(O)
    - 처음에 입력된 개숫가 N이라 가정
    - 탐색을 한 번 시행했을 때 절반이 버려지므로 N/2
    - 두 번째 시행 후 또 반이 버려져 1/2 * N/2
    - k 번째 시행 후 에는 (1/2)^k * N/2
    - 최악의 경우에는 남는 자료가 1개인 경우 이므로 (1/2)^k * N = 1 (여기서 =는 무조건 1과 같다가 아닌 1에 근접 한 값을 의미)
    - 양 변에 2^k를 곱한 뒤 log를 씌워 k의 결과 값을 도출하면 밑이 2인 logN이 나온다.
    - 따라서 시간 복잡도는 `O(logN)`




### 공간 복잡도

메모리를 얼마나 사용하는지 표현

ex)  문제 해결 중, n x n 크기의 2차원 배열을 할당했으면 공간 복잡도는 `n^2`

보통 문제를 풀 때에는 공간 복잡도 보다는 시간 복잡도를 더 우선적으로 고려하게 되지만,

빅데이터 처리와 같은 경우에는 공간 복잡도가 더 중요하기도 하다.

